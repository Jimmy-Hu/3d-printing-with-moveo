/*
 * Module code.
 *
 * Generated by SIP 4.19.19
 */

#include "sipAPISavitar.h"

#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/SceneNode.sip"
    #include "SceneNode.h"
#line 12 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"

#line 27 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <string>
#line 16 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"
#line 306 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <map>
#line 19 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"
#line 80 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <vector>
#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"
#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/MeshData.sip"
    #include "MeshData.h"
#line 25 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"


class sipSceneNode : public  ::SceneNode
{
public:
    sipSceneNode();
    sipSceneNode(const  ::SceneNode&);
    ~sipSceneNode();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipSceneNode(const sipSceneNode &);
    sipSceneNode &operator = (const sipSceneNode &);
};

sipSceneNode::sipSceneNode():  ::SceneNode(), sipPySelf(SIP_NULLPTR)
{
}

sipSceneNode::sipSceneNode(const  ::SceneNode& a0):  ::SceneNode(a0), sipPySelf(SIP_NULLPTR)
{
}

sipSceneNode::~sipSceneNode()
{
    sipInstanceDestroyedEx(&sipPySelf);
}


extern "C" {static PyObject *meth_SceneNode_getMeshData(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_getMeshData(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_SceneNode, &sipCpp))
        {
             ::MeshData*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = &sipCpp->getMeshData();
            Py_END_ALLOW_THREADS

            return sipConvertFromType(sipRes,sipType_MeshData,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_getMeshData, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_getChildren(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_getChildren(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_SceneNode, &sipCpp))
        {
             ::std::vector< ::SceneNode*>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::vector< ::SceneNode*>(sipCpp->getChildren());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_vector_0101SceneNode,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_getChildren, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_getTransformation(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_getTransformation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_SceneNode, &sipCpp))
        {
             ::std::string*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::string(sipCpp->getTransformation());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_string,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_getTransformation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_setTransformation(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_setTransformation(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::std::string* a0;
        int a0State = 0;
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_SceneNode, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setTransformation(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_setTransformation, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_getSettings(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_getSettings(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_SceneNode, &sipCpp))
        {
             ::std::map< ::std::string, ::std::string>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::map< ::std::string, ::std::string>(sipCpp->getSettings());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_map_0100std_string_0100std_string,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_getSettings, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_setSetting(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_setSetting(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::std::string* a0;
        int a0State = 0;
         ::std::string* a1;
        int a1State = 0;
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J1", &sipSelf, sipType_SceneNode, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setSetting(*a0,*a1);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);
            sipReleaseType(a1,sipType_std_string,a1State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_setSetting, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_SceneNode_addChild(PyObject *, PyObject *);}
static PyObject *meth_SceneNode_addChild(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode* a0;
         ::SceneNode *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:", &sipSelf, sipType_SceneNode, &sipCpp, sipType_SceneNode, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->addChild(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_SceneNode, sipName_addChild, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_SceneNode(void *, int);}
static void release_SceneNode(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipSceneNode *>(sipCppV);
    else
        delete reinterpret_cast< ::SceneNode *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_SceneNode(void *, SIP_SSIZE_T, void *);}
static void assign_SceneNode(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::SceneNode *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::SceneNode *>(sipSrc);
}


extern "C" {static void *array_SceneNode(SIP_SSIZE_T);}
static void *array_SceneNode(SIP_SSIZE_T sipNrElem)
{
    return new  ::SceneNode[sipNrElem];
}


extern "C" {static void *copy_SceneNode(const void *, SIP_SSIZE_T);}
static void *copy_SceneNode(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::SceneNode(reinterpret_cast<const  ::SceneNode *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_SceneNode(sipSimpleWrapper *);}
static void dealloc_SceneNode(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipSceneNode *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_SceneNode(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_SceneNode(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_SceneNode(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipSceneNode *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipSceneNode();
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::SceneNode* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_SceneNode, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipSceneNode(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_SceneNode[] = {
    {SIP_MLNAME_CAST(sipName_addChild), meth_SceneNode_addChild, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getChildren), meth_SceneNode_getChildren, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getMeshData), meth_SceneNode_getMeshData, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getSettings), meth_SceneNode_getSettings, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getTransformation), meth_SceneNode_getTransformation, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_setSetting), meth_SceneNode_setSetting, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_setTransformation), meth_SceneNode_setTransformation, METH_VARARGS, SIP_NULLPTR}
};


sipClassTypeDef sipTypeDef_Savitar_SceneNode = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_SceneNode,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_SceneNode,
        {0, 0, 1},
        7, methods_SceneNode,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_SceneNode,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_SceneNode,
    assign_SceneNode,
    array_SceneNode,
    copy_SceneNode,
    release_SceneNode,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 306 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <map>
#line 401 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"

#line 27 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <string>
#line 405 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"


extern "C" {static void assign_std_map_0100std_string_0100std_string(void *, SIP_SSIZE_T, void *);}
static void assign_std_map_0100std_string_0100std_string(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::std::map< ::std::string, ::std::string> *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::std::map< ::std::string, ::std::string> *>(sipSrc);
}


extern "C" {static void *array_std_map_0100std_string_0100std_string(SIP_SSIZE_T);}
static void *array_std_map_0100std_string_0100std_string(SIP_SSIZE_T sipNrElem)
{
    return new  ::std::map< ::std::string, ::std::string>[sipNrElem];
}


extern "C" {static void *copy_std_map_0100std_string_0100std_string(const void *, SIP_SSIZE_T);}
static void *copy_std_map_0100std_string_0100std_string(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::std::map< ::std::string, ::std::string>(reinterpret_cast<const  ::std::map< ::std::string, ::std::string> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_std_map_0100std_string_0100std_string(void *, int);}
static void release_std_map_0100std_string_0100std_string(void *ptr, int)
{
    Py_BEGIN_ALLOW_THREADS
    delete reinterpret_cast< ::std::map< ::std::string, ::std::string> *>(ptr);
    Py_END_ALLOW_THREADS
}



extern "C" {static int convertTo_std_map_0100std_string_0100std_string(PyObject *, void **, int *, PyObject *);}
static int convertTo_std_map_0100std_string_0100std_string(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
     ::std::map< ::std::string, ::std::string> **sipCppPtr = reinterpret_cast< ::std::map< ::std::string, ::std::string> **>(sipCppPtrV);

#line 364 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
        PyObject *key_object, *value_object;
        SIP_SSIZE_T i = 0;

        // Check the type if that is all that is required.
        if (sipIsErr == nullptr)
        {
            if (!PyDict_Check(sipPy))
            {
                return 0;
            }

            while (PyDict_Next(sipPy, &i, &key_object, &value_object))
            {
                if (!sipCanConvertToType(key_object, sipType_std_string, SIP_NOT_NONE))
                {
                    return 0;
                }

                if (!sipCanConvertToType(value_object, sipType_std_string, SIP_NOT_NONE))
                {
                    return 0;
                }
            }

            return 1;
        }

        std::map<std::string, std::string> *std_map = new std::map<std::string, std::string>;

        while (PyDict_Next(sipPy, &i, &key_object, &value_object))
        {
            int key_state, value_state;

            std::string *key = reinterpret_cast<std::string *>(sipConvertToType(key_object, sipType_std_string, sipTransferObj, SIP_NOT_NONE, &key_state, sipIsErr));
            std::string *value = reinterpret_cast<std::string *>(sipConvertToType(value_object, sipType_std_string, sipTransferObj, SIP_NOT_NONE, &value_state, sipIsErr));

            if (*sipIsErr)
            {
                sipReleaseType(key, sipType_std_string, key_state);
                sipReleaseType(value, sipType_std_string, value_state);

                delete std_map;
                return 0;
            }

            (*std_map)[*key] = *value;

            sipReleaseType(key, sipType_std_string, key_state);
            sipReleaseType(value, sipType_std_string, value_state);
        }

        *sipCppPtr = std_map;

        return sipGetState(sipTransferObj);
#line 500 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"
}


extern "C" {static PyObject *convertFrom_std_map_0100std_string_0100std_string(void *, PyObject *);}
static PyObject *convertFrom_std_map_0100std_string_0100std_string(void *sipCppV, PyObject *sipTransferObj)
{
    ::std::map< ::std::string, ::std::string> *sipCpp = reinterpret_cast< ::std::map< ::std::string, ::std::string> *>(sipCppV);

#line 310 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
        // Create the dictionary.
        PyObject *result_dict = PyDict_New();

        if (!result_dict)
        {
            return NULL;
        }

        // Set the dictionary elements.
        std::map<std::string, std::string>::const_iterator i = sipCpp->begin();

        while (i != sipCpp->end())
        {
            std::string *key = new std::string((*i).first);
            std::string *value = new std::string((*i).second);

            PyObject *key_object = sipConvertFromNewType(key, sipType_std_string, sipTransferObj);
            PyObject *value_object = sipConvertFromNewType(value, sipType_std_string, sipTransferObj);

            if (key_object == NULL || value_object == NULL || PyDict_SetItem(result_dict, key_object, value_object) < 0)
            {
                Py_DECREF(result_dict);

                if (key_object)
                {
                    Py_DECREF(key_object);
                }
                else
                {
                    delete key;
                }

                if (value_object)
                {
                    Py_DECREF(value_object);
                }
                else
                {
                    delete value;
                }

                return nullptr;
            }

            Py_DECREF(key_object);
            Py_DECREF(value_object);

            ++i;
        }

        return result_dict;
#line 561 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart2.cpp"
}


sipMappedTypeDef sipTypeDef_Savitar_std_map_0100std_string_0100std_string = {
    {
        -1,
        SIP_NULLPTR,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_0,     /* std::map<std::string,std::string> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_std_map_0100std_string_0100std_string,
    array_std_map_0100std_string_0100std_string,
    copy_std_map_0100std_string_0100std_string,
    release_std_map_0100std_string_0100std_string,
    convertTo_std_map_0100std_string_0100std_string,
    convertFrom_std_map_0100std_string_0100std_string
};
