/*
 * Module code.
 *
 * Generated by SIP 4.19.19
 */

#include "sipAPISavitar.h"

#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/MeshData.sip"
    #include "MeshData.h"
#line 12 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"

#line 174 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <vector>
    #include <cstdint>
    #include "Types.h"
#line 18 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"


class sipMeshData : public  ::MeshData
{
public:
    sipMeshData();
    sipMeshData(const  ::MeshData&);
    ~sipMeshData();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipMeshData(const sipMeshData &);
    sipMeshData &operator = (const sipMeshData &);
};

sipMeshData::sipMeshData():  ::MeshData(), sipPySelf(SIP_NULLPTR)
{
}

sipMeshData::sipMeshData(const  ::MeshData& a0):  ::MeshData(a0), sipPySelf(SIP_NULLPTR)
{
}

sipMeshData::~sipMeshData()
{
    sipInstanceDestroyedEx(&sipPySelf);
}


extern "C" {static PyObject *meth_MeshData_getVerticesAsBytes(PyObject *, PyObject *);}
static PyObject *meth_MeshData_getVerticesAsBytes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::MeshData *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_MeshData, &sipCpp))
        {
             ::bytearray*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::bytearray(sipCpp->getVerticesAsBytes());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_bytearray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MeshData, sipName_getVerticesAsBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_MeshData_getFacesAsBytes(PyObject *, PyObject *);}
static PyObject *meth_MeshData_getFacesAsBytes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::MeshData *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_MeshData, &sipCpp))
        {
             ::bytearray*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::bytearray(sipCpp->getFacesAsBytes());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_bytearray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MeshData, sipName_getFacesAsBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_MeshData_getFlatVerticesAsBytes(PyObject *, PyObject *);}
static PyObject *meth_MeshData_getFlatVerticesAsBytes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::MeshData *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_MeshData, &sipCpp))
        {
             ::bytearray*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::bytearray(sipCpp->getFlatVerticesAsBytes());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_bytearray,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MeshData, sipName_getFlatVerticesAsBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_MeshData_setVerticesFromBytes(PyObject *, PyObject *);}
static PyObject *meth_MeshData_setVerticesFromBytes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::bytearray* a0;
        int a0State = 0;
         ::MeshData *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_MeshData, &sipCpp, sipType_bytearray,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setVerticesFromBytes(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::bytearray *>(a0),sipType_bytearray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MeshData, sipName_setVerticesFromBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_MeshData_setFacesFromBytes(PyObject *, PyObject *);}
static PyObject *meth_MeshData_setFacesFromBytes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
        const  ::bytearray* a0;
        int a0State = 0;
         ::MeshData *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_MeshData, &sipCpp, sipType_bytearray,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setFacesFromBytes(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(const_cast< ::bytearray *>(a0),sipType_bytearray,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_MeshData, sipName_setFacesFromBytes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_MeshData(void *, int);}
static void release_MeshData(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipMeshData *>(sipCppV);
    else
        delete reinterpret_cast< ::MeshData *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_MeshData(void *, SIP_SSIZE_T, void *);}
static void assign_MeshData(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::MeshData *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::MeshData *>(sipSrc);
}


extern "C" {static void *array_MeshData(SIP_SSIZE_T);}
static void *array_MeshData(SIP_SSIZE_T sipNrElem)
{
    return new  ::MeshData[sipNrElem];
}


extern "C" {static void *copy_MeshData(const void *, SIP_SSIZE_T);}
static void *copy_MeshData(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::MeshData(reinterpret_cast<const  ::MeshData *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_MeshData(sipSimpleWrapper *);}
static void dealloc_MeshData(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipMeshData *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_MeshData(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_MeshData(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_MeshData(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipMeshData *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipMeshData();
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::MeshData* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_MeshData, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipMeshData(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_MeshData[] = {
    {SIP_MLNAME_CAST(sipName_getFacesAsBytes), meth_MeshData_getFacesAsBytes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getFlatVerticesAsBytes), meth_MeshData_getFlatVerticesAsBytes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getVerticesAsBytes), meth_MeshData_getVerticesAsBytes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_setFacesFromBytes), meth_MeshData_setFacesFromBytes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_setVerticesFromBytes), meth_MeshData_setVerticesFromBytes, METH_VARARGS, SIP_NULLPTR}
};


sipClassTypeDef sipTypeDef_Savitar_MeshData = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_MeshData,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_MeshData,
        {0, 0, 1},
        5, methods_MeshData,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_MeshData,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_MeshData,
    assign_MeshData,
    array_MeshData,
    copy_MeshData,
    release_MeshData,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};

#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Scene.sip"
    #include "Scene.h"
#line 335 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"

#line 27 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <string>
#line 339 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"
#line 306 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <map>
#line 342 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"
#line 22 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/SceneNode.sip"
    #include "SceneNode.h"
#line 345 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"
#line 80 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/python/Types.sip"
    #include <vector>
#line 348 "/home/tiao/git_ws/moveo_moveit_ws/src/Cura/libSavitar/build/python/sipSavitarpart1.cpp"


class sipScene : public  ::Scene
{
public:
    sipScene();
    sipScene(const  ::Scene&);
    ~sipScene();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipScene(const sipScene &);
    sipScene &operator = (const sipScene &);
};

sipScene::sipScene():  ::Scene(), sipPySelf(SIP_NULLPTR)
{
}

sipScene::sipScene(const  ::Scene& a0):  ::Scene(a0), sipPySelf(SIP_NULLPTR)
{
}

sipScene::~sipScene()
{
    sipInstanceDestroyedEx(&sipPySelf);
}


extern "C" {static PyObject *meth_Scene_getSceneNodes(PyObject *, PyObject *);}
static PyObject *meth_Scene_getSceneNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Scene, &sipCpp))
        {
             ::std::vector< ::SceneNode*>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::vector< ::SceneNode*>(sipCpp->getSceneNodes());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_vector_0101SceneNode,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_getSceneNodes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_Scene_getAllSceneNodes(PyObject *, PyObject *);}
static PyObject *meth_Scene_getAllSceneNodes(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Scene, &sipCpp))
        {
             ::std::vector< ::SceneNode*>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::vector< ::SceneNode*>(sipCpp->getAllSceneNodes());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_vector_0101SceneNode,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_getAllSceneNodes, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_Scene_addSceneNode(PyObject *, PyObject *);}
static PyObject *meth_Scene_addSceneNode(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::SceneNode* a0;
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ:", &sipSelf, sipType_Scene, &sipCpp, sipType_SceneNode, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->addSceneNode(a0);
            Py_END_ALLOW_THREADS

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_addSceneNode, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_Scene_getMetadata(PyObject *, PyObject *);}
static PyObject *meth_Scene_getMetadata(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Scene, &sipCpp))
        {
             ::std::map< ::std::string, ::std::string>*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::map< ::std::string, ::std::string>(sipCpp->getMetadata());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_map_0100std_string_0100std_string,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_getMetadata, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_Scene_getUnit(PyObject *, PyObject *);}
static PyObject *meth_Scene_getUnit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Scene, &sipCpp))
        {
             ::std::string*sipRes;

            Py_BEGIN_ALLOW_THREADS
            sipRes = new  ::std::string(sipCpp->getUnit());
            Py_END_ALLOW_THREADS

            return sipConvertFromNewType(sipRes,sipType_std_string,SIP_NULLPTR);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_getUnit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


extern "C" {static PyObject *meth_Scene_setUnit(PyObject *, PyObject *);}
static PyObject *meth_Scene_setUnit(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = SIP_NULLPTR;

    {
         ::std::string* a0;
        int a0State = 0;
         ::Scene *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_Scene, &sipCpp, sipType_std_string,&a0, &a0State))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->setUnit(*a0);
            Py_END_ALLOW_THREADS
            sipReleaseType(a0,sipType_std_string,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Scene, sipName_setUnit, SIP_NULLPTR);

    return SIP_NULLPTR;
}


/* Call the instance's destructor. */
extern "C" {static void release_Scene(void *, int);}
static void release_Scene(void *sipCppV, int sipState)
{
    Py_BEGIN_ALLOW_THREADS

    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipScene *>(sipCppV);
    else
        delete reinterpret_cast< ::Scene *>(sipCppV);

    Py_END_ALLOW_THREADS
}


extern "C" {static void assign_Scene(void *, SIP_SSIZE_T, void *);}
static void assign_Scene(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Scene *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Scene *>(sipSrc);
}


extern "C" {static void *array_Scene(SIP_SSIZE_T);}
static void *array_Scene(SIP_SSIZE_T sipNrElem)
{
    return new  ::Scene[sipNrElem];
}


extern "C" {static void *copy_Scene(const void *, SIP_SSIZE_T);}
static void *copy_Scene(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Scene(reinterpret_cast<const  ::Scene *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Scene(sipSimpleWrapper *);}
static void dealloc_Scene(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipScene *>(sipGetAddress(sipSelf))->sipPySelf = SIP_NULLPTR;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_Scene(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_Scene(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Scene(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipScene *sipCpp = SIP_NULLPTR;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, ""))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipScene();
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::Scene* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, SIP_NULLPTR, sipUnused, "J9", sipType_Scene, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp = new sipScene(*a0);
            Py_END_ALLOW_THREADS

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return SIP_NULLPTR;
}


static PyMethodDef methods_Scene[] = {
    {SIP_MLNAME_CAST(sipName_addSceneNode), meth_Scene_addSceneNode, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getAllSceneNodes), meth_Scene_getAllSceneNodes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getMetadata), meth_Scene_getMetadata, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getSceneNodes), meth_Scene_getSceneNodes, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_getUnit), meth_Scene_getUnit, METH_VARARGS, SIP_NULLPTR},
    {SIP_MLNAME_CAST(sipName_setUnit), meth_Scene_setUnit, METH_VARARGS, SIP_NULLPTR}
};


sipClassTypeDef sipTypeDef_Savitar_Scene = {
    {
        -1,
        SIP_NULLPTR,
        SIP_NULLPTR,
        SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_Scene,
        {SIP_NULLPTR},
        SIP_NULLPTR
    },
    {
        sipNameNr_Scene,
        {0, 0, 1},
        6, methods_Scene,
        0, SIP_NULLPTR,
        0, SIP_NULLPTR,
        {SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR, SIP_NULLPTR},
    },
    SIP_NULLPTR,
    -1,
    -1,
    SIP_NULLPTR,
    SIP_NULLPTR,
    init_type_Scene,
    SIP_NULLPTR,
    SIP_NULLPTR,
#if PY_MAJOR_VERSION >= 3
    SIP_NULLPTR,
    SIP_NULLPTR,
#else
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
#endif
    dealloc_Scene,
    assign_Scene,
    array_Scene,
    copy_Scene,
    release_Scene,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR,
    SIP_NULLPTR
};
